////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2005 Jeremy Jurksztowicz
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
// and associated documentation files (the "Software"), to deal in the Software without restriction, 
// including without limitation the rights to use, copy, modify, merge, publish, distribute, 
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is 
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or 
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT 
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _ark_Generic_h
#define _ark_Generic_h

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Include Files
//
#include <iostream>
#include <sstream>
#include <cstring>
#include <cassert>
#include <typeinfo>
#include <stdexcept>

#ifdef ARK_USE_BOOST
	#include <boost/static_assert.hpp>
	#include <boost/call_traits.hpp>
	#include <boost/type_traits.hpp>
	
	#define ARK_STATIC_ASSERT(P)	BOOST_STATIC_ASSERT(P)
	#define ARK_REFERENCE(T)		typename boost::call_traits<T>::reference
	#define ARK_CONST_REFERENCE(T)	typename boost::call_traits<T>::const_reference
	#define ARK_IS_POD(T)			boost::is_pod<T>::value
#else
	// Stupid hacks to get preprocessor to recognize shit.
	#define ARK_CONCAT1(A, B) A ## B
	#define ARK_CONCAT2(A, B) ARK_CONCAT1(A, B)
	#define ARK_UNIQUE(PRE) ARK_CONCAT2(PRE, __LINE__)

	template<int* N> struct ark_eat_warning {};
	#define ARK_STATIC_ASSERT(P)	static int ARK_UNIQUE(error)[(P ? 1 : -1)]; typedef ark_eat_warning<ARK_UNIQUE(error)> ARK_UNIQUE(warning_eater)
	#define ARK_REFERENCE(T)		T&
	#define ARK_CONST_REFERENCE(T)	T const& 
	#define ARK_IS_POD(T)			false
#endif

namespace ark {
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
///  BadGenericGet
///
class BadGenericGet : public std::exception
{
public:
	BadGenericGet (std::type_info const& from, std::type_info const& to):
		_from(from.name()), _to(to.name())
	{
		std::ostringstream msg;
		msg << "Requested value of type " << _to
			<< " from Generic containing value of type " << _from << ".";
		_desc = msg.str();
	}
	~BadGenericGet ( ) throw( ) { }
	
	const char * what ( ) const throw ( ) { return _desc.c_str(); }
	const char * containedTypeName ( ) const throw ( ) { return _from; }
	const char * requestedTypeName ( ) const throw ( ) { return _to; }
	
private:
	const char * _from, * _to;
	std::string _desc;
};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/// Generic
///		This struct is a compact (<= 128 bytes) data structure which holds heterogenous data. It is
///		designed to pass arbitrary data through message ports without resorting to dynamic memory.
///		Generic can only hold copyable types.
///
template<unsigned int totalSize>
class Generic
{			
private:
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/// DataWrapperBase
///		Provides the base interface for data objects. Data objects are objects used to keep track of
///		non-pod data objects lifetime. By using a data wrapper we can ensure that the correct 
///		destructor will be called for generic data, when this object is destroyed.
///
	class DataWrapperBase 
	{ 
		unsigned char * _storage;
	protected:
		template<typename A>
		A * rawAssign (A const& a) 
		{ 
			A * init = new (_storage) A(a);
			return init;
		}
	public: 
				 DataWrapperBase (unsigned char * stor): _storage(stor) { }
		virtual ~DataWrapperBase ( ) { }
		virtual  DataWrapperBase * clone (unsigned char *, unsigned char *) = 0;
		virtual const std::type_info & type ( ) const = 0;
	};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/// DataWrapper
///		Implements the core interface of DataWrapperBase (above) to provide basic object copying
///		and correct object destruction for any type T.
///
	template <typename T>
	class DataWrapper : public DataWrapperBase {
		ARK_STATIC_ASSERT(sizeof(T*) == sizeof(void*));
		T * _ref;
	public:
		DataWrapper (T const& t, unsigned char * stor): 
		DataWrapperBase(stor), _ref(0) { _ref = this->template rawAssign<T>(t); }
		~ DataWrapper ( ) { _ref->~T(); }
		
		DataWrapperBase * clone (unsigned char * wrapmem, unsigned char * stor) {
			return new (wrapmem) DataWrapper<T>(*_ref, stor);
		}
		const std::type_info & type( ) const { return typeid(T); }
	};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Data Members.
//
	// Make sure that the totalSize is capable of containing the bare minimum data.
	ARK_STATIC_ASSERT(totalSize >= 
		  sizeof(unsigned char*)
		+ sizeof(DataWrapperBase*)
		+ sizeof(unsigned char*)
		+ sizeof(DataWrapper<int>));
		
	static const unsigned int _buffBytes = totalSize	
		- sizeof(unsigned char*) 
		- sizeof(DataWrapperBase*) 
		- sizeof(unsigned char*)
		- sizeof(DataWrapper<int>);
	
	unsigned char		_buf[_buffBytes];
	DataWrapperBase	*	_data;
	unsigned char		_dataBuf[sizeof(DataWrapper<int>)];
	
	// TODO: Note that there is room for optimization, for instance stuffing the _data storage at
	// the end of the regular buf, so that it's memory is available for some big POD. 
	
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
	template <unsigned int S>
	void _copy (Generic<S> const& other)
	{
		ARK_STATIC_ASSERT(S <= totalSize);
		if(other._data)
			_data = other._data->clone(_dataBuf, _buf);
		
		else 
		{ 
			const unsigned otherBuffBytes = other.bufferSize();
			_data = 0;
			std::memcpy(_buf, other.buffer(), otherBuffBytes);
		 // std::memset(_buf + otherBuffBytes, 0, _buffBytes - otherBuffBytes);
		 // You can clear the end of the buffer if you like.
		}
	}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
//
public:
	Generic ( ): _data(0) { }
		
	template<typename T>
	Generic (T const& val): _data(0)
	{ 
		ARK_STATIC_ASSERT(sizeof(T) <= _buffBytes);		
		if(ARK_IS_POD(T) == true)
			*reinterpret_cast<T*>(_buf) = val;
		else _data = new (_dataBuf) DataWrapper<T>(val, _buf);
	}	
	
	template<typename T>
	Generic& operator = (T const& val)
	{ 
		ARK_STATIC_ASSERT(sizeof(T) <= _buffBytes);
		this->clearBuffer();
		
		if(ARK_IS_POD(T) == true)
			*reinterpret_cast<T*>(_buf) = val;
		else _data = new (_dataBuf) DataWrapper<T>(val, _buf);
		return *this;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
	Generic (Generic const& other): _data(0)
	{	
		this->clearBuffer();
		this->_copy(other);
	}
	
	template<unsigned int S>
	Generic (Generic<S> const& other): _data(0)
	{	
		this->clearBuffer();
		this->_copy(other);
	}

	Generic& operator = (Generic const& other)
	{	
		this->clearBuffer();
		this->_copy(other);
		return *this;
	}
	
	template<unsigned int S>
	Generic& operator = (Generic<S> const& other)
	{	
		this->clearBuffer();
		this->_copy(other);
		return *this;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
	~Generic ( ) 
	{ 	
		this->clearBuffer();
	}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Accessors
//
private:
	template<typename T>
	void safetyCheck ( ) 
	{
		// IMPORTANT!
		// typeid is not standardized and I have personally been bitten hard by the below code,
		// so I offer it only in the interest of giving you the maximum freedom to destroy yourself.
		if(_data)
			if(typeid(T) != _data->type())
				throw BadGenericGet(typeid(T), _data->type());
	}

public:
	template<typename T> 
	ARK_REFERENCE(T) get ( ) 
	{ 
		ARK_STATIC_ASSERT(sizeof(T) <= _buffBytes);
		return *reinterpret_cast<T*>(_buf); 
	}
	
	template<typename T> 
	ARK_CONST_REFERENCE(T) get ( ) const
	{ 
		ARK_STATIC_ASSERT(sizeof(T) <= _buffBytes);
		return *reinterpret_cast<T const*>(_buf); 
	}
	
	template<typename T> 
	ARK_REFERENCE(T) getChecked ( ) 
	{ 
		this->template safetyCheck<T>();
		return this->template get<T>();
	}
	
	template<typename T> 
	ARK_CONST_REFERENCE(T) getChecked ( ) const
	{ 
		this->template safetyCheck<T>();
		return this->template get<T>();
	}
	
	template<typename T> T * getPointer ( )
	{ 
		ARK_STATIC_ASSERT(sizeof(T) <= _buffBytes);
		this->template safetyCheck<T>();
		return reinterpret_cast<T*>(_buf); 
	}
	
	template<typename T> T const * getPointer ( ) const
	{ 
		ARK_STATIC_ASSERT(sizeof(T) <= _buffBytes);
		this->template safetyCheck<T>();
		return reinterpret_cast<T*>(_buf); 
	}
	
	template<typename T> T * getPointerChecked ( )
	{ 
		this->template safetyCheck<T>();
		return this->template getPointer<T>(); 
	}
	
	template<typename T> T const * getPointerChecked ( ) const
	{ 
		this->template safetyCheck<T>();
		return this->template getPointer<T>();
	}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////	
	inline void *			buffer		( )			{ return reinterpret_cast<void*>(_buf); }
	inline void const *		buffer		( )	const	{ return reinterpret_cast<void const*>(_buf); }
	inline unsigned int		bufferSize	( ) const	{ return _buffBytes; }

	void clearBuffer ( ) 
	{ 
		if(_data)
		{
			_data->~DataWrapperBase();
			_data = 0;
		}
		// TODO: The name of this function has 'clear' in it.
		// std::memset(_buf, 0, _buffBytes);
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper functions
//
template<typename T, unsigned int S>
inline ARK_REFERENCE(T) Get (Generic<S>& note)
{
	return note.template get<T>();
}

template<typename T, unsigned int S>
inline T * GetArray (Generic<S>& note)
{
	return note.template getArray<T>();
}
//
// CONST VERSIONS
//
template<typename T, unsigned int S>
inline ARK_CONST_REFERENCE(T) Get (Generic<S> const& note)
{
//	return note.template get<T>();
}

template<typename T, unsigned int S>
inline T const * GetArray (Generic<S> const& note)
{
	return note.template getArray<T>();
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<unsigned int S>
std::ostream& operator << (std::ostream& os, Generic<S> const& note)
{
	os << note.bufferSize();
	os.write((const char*)note.buffer(), note.bufferSize());

	return os;
}

// TODO: The type information is lost when reading into a generic, so subsequent
// calls to getXSafely will invariably throw exceptions.
//
template<unsigned int S>
std::istream& operator >> (std::istream& is, Generic<S>& note)
{
	unsigned buffSize;
	is >> buffSize;

	note = Generic<S>();
	if(buffSize <= note.bufferSize())
		is.read((char*)note.buffer(), buffSize);
	
	else 
	{
		// TODO: Probably not best to fail silently.
		is.ignore(buffSize);
		std::memset(note.buffer(), 0, note.bufferSize());
	}
	
	return is;
}

} // END namespace ark

#endif // _ark_Generic_h